AWSTemplateFormatVersion: '2010-09-09'

Parameters:
  AppName:
    Type: String

  KeyPairName:
    Type: String
    Description: Enter a name for the key pair

  BastionAmiId:
    Type: AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>

  AppAmiId:
    Type: String

  BastionEC2DiskSize:
    Type: Number

  AppEC2DiskSize:
    Type: Number

Resources:

  KeyPairHelperRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal: { Service: lambda.amazonaws.com }
            Action: sts:AssumeRole
      Path: /
      Policies:
        - PolicyName: create-ec2-kp
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - ec2:CreateKeyPair
                  - ec2:DeleteKeyPair
                  - ec2:DescribeKeyPairs
                Resource: "*"
              - Effect: Allow
                Action:
                  - secretsmanager:CreateSecret
                  - secretsmanager:PutSecretValue
                  - secretsmanager:DescribeSecret
                  - secretsmanager:DeleteSecret
                  - secretsmanager:TagResource
                Resource: "*"
              - Effect: Allow
                Action:
                  - kms:Encrypt
                  - kms:GenerateDataKey
                Resource: "*"
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: "*"

  KeyPairHelper:
    Type: AWS::Lambda::Function
    Properties:
      Description: Create/update/delete EC2 key pair and mirror private key in Secrets Manager
      Role: !GetAtt KeyPairHelperRole.Arn
      Runtime: python3.13
      Handler: index.handler
      Timeout: 180

      Code:
        ZipFile: |
          import boto3, json, os, urllib.request
          from botocore.exceptions import ClientError

          ec2 = boto3.client('ec2')
          sm  = boto3.client('secretsmanager')
          ssm = boto3.client('ssm')

          def respond(event, context, status, data=None, physical_id=None, reason=None, no_echo=False):
            if not data: data = {}
            response_body = json.dumps({
              "Status": status,
              "Reason": reason or f"See CloudWatch Logs: {context.log_stream_name}",
              "PhysicalResourceId": physical_id or context.log_stream_name,
              "StackId": event["StackId"],
              "RequestId": event["RequestId"],
              "LogicalResourceId": event["LogicalResourceId"],
              "NoEcho": no_echo,
              "Data": data
            }).encode("utf-8")
            req = urllib.request.Request(event["ResponseURL"], data=response_body, method="PUT")
            req.add_header("Content-Type", "")
            urllib.request.urlopen(req)

          def create_or_rotate_secret(secret_name, secret_string):
            # Create if missing, else put a new version
            try:
              sm.create_secret(Name=secret_name, SecretString=secret_string)
            except ClientError as e:
              if e.response["Error"]["Code"] == "ResourceExistsException":
                sm.put_secret_value(SecretId=secret_name, SecretString=secret_string)
              else:
                raise

          def delete_secret_if_exists(secret_name):
            try:
              sm.describe_secret(SecretId=secret_name)
            except ClientError as e:
              if e.response["Error"]["Code"] in ("ResourceNotFoundException", "InvalidRequestException"):
                return
              raise
            # RecoveryWindowInDays: set to 0 + ForceDeleteWithoutRecovery for immediate delete
            sm.delete_secret(SecretId=secret_name, ForceDeleteWithoutRecovery=True)

          def handler(event, context):
            props = event["ResourceProperties"]
            key_name   = props["KeyPairName"]
            secret_name = props.get("SecretName", f"/ec2/keypairs/{key_name}")

            try:
              if event["RequestType"] in ("Create", "Update"):
                # If Update and key already exists, delete & recreate to ensure material matches secret
                exists = False
                try:
                  ec2.describe_key_pairs(KeyNames=[key_name])
                  exists = True
                except ClientError as e:
                  if e.response["Error"]["Code"] != "InvalidKeyPair.NotFound":
                    raise

                if exists and event["RequestType"] == "Update":
                  ec2.delete_key_pair(KeyName=key_name)

                # Create key pair (returns private material once)
                kp = ec2.create_key_pair(KeyName=key_name)  # default RSA
                pem = kp["KeyMaterial"]

                create_or_rotate_secret(secret_name, pem)

                respond(event, context, "SUCCESS",
                        data={"SecretName": secret_name, "KeyPairName": key_name},
                        physical_id=key_name)

              elif event["RequestType"] == "Delete":
                # Delete both secret and key pair (ignore if gone)
                try:
                  ec2.delete_key_pair(KeyName=key_name)
                except ClientError as e:
                  if e.response["Error"]["Code"] != "InvalidKeyPair.NotFound":
                    raise
                delete_secret_if_exists(secret_name)
                respond(event, context, "SUCCESS", data={}, physical_id=key_name)

              else:
                respond(event, context, "FAILED", reason=f"Unknown RequestType {event['RequestType']}")
            except Exception as e:
              respond(event, context, "FAILED", reason=str(e), physical_id=key_name)

  CreateKeyPair:
    Type: Custom::Ec2KeyToSecret
    Properties:
      ServiceToken: !GetAtt KeyPairHelper.Arn
      KeyPairName:  !Ref KeyPairName

  KeyPairNameParam:
    Type: AWS::SSM::Parameter
    Properties:
      Name: !Sub "/ec2/keypairs/${KeyPairName}/name"
      Type: String
      Value: !Ref KeyPairName

  BastionEC2IAMRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal: { Service: ec2.amazonaws.com }
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
        - arn:aws:iam::aws:policy/CloudWatchAgentServerPolicy
      Tags:
        - Key: env
          Value: '{{resolve:ssm:/params/env_name}}'

  BastionEC2InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      InstanceProfileName: !Sub '{{resolve:ssm:/params/env_name}}-bastion-instance-profile'
      Roles: 
        - !Ref BastionEC2IAMRole

  AppEC2IAMRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal: { Service: ec2.amazonaws.com }
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
        - arn:aws:iam::aws:policy/CloudWatchAgentServerPolicy
      Policies:
        - PolicyName: S3FullAccessPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action: "s3:*"
                Resource:
                  - !Sub '{{resolve:ssm:/s3/${AppName}-bucket/arn}}'
                  - !Sub '{{resolve:ssm:/s3/${AppName}-bucket/arn}}/*'
      Tags:
        - Key: env
          Value: '{{resolve:ssm:/params/env_name}}'

  AppEC2InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      InstanceProfileName: !Sub '{{resolve:ssm:/params/env_name}}-${AppName}-instance-profile'
      Roles: 
        - !Ref AppEC2IAMRole
   
  BastionInstance:
    Type: AWS::EC2::Instance
    Properties:
      IamInstanceProfile: !Ref BastionEC2InstanceProfile
      InstanceType: '{{resolve:ssm:/params/bastion_instance_type}}'
      ImageId: !Ref BastionAmiId
      SubnetId: '{{resolve:ssm:/net/subnets/privatesubnet1/id}}' 
      BlockDeviceMappings:
        - DeviceName: /dev/xvda
          Ebs:
            VolumeSize: !Ref BastionEC2DiskSize
            VolumeType: gp3
            Encrypted: true
      KeyName: !Ref KeyPairName
      SecurityGroupIds: 
        - '{{resolve:ssm:/ec2/securitygroups/bastion-sg/id}}'
      Tags:
      - Key: Name
        Value: Bastion

  LaunchTemplate:
    Type: AWS::EC2::LaunchTemplate
    Properties:
      LaunchTemplateName: !Sub "${AppName}-ec2-template"
      LaunchTemplateData:
        IamInstanceProfile: 
          Name: !Ref AppEC2InstanceProfile
        ImageId: !Ref AppAmiId
        InstanceType: '{{resolve:ssm:/params/app_instance_type}}'
        SecurityGroupIds:
          - '{{resolve:ssm:/ec2/securitygroups/app-ec2-sg/id}}'
        KeyName: !Ref KeyPairName
        BlockDeviceMappings:
          - DeviceName: "/dev/sda1"
            Ebs:
              VolumeSize: !Ref AppEC2DiskSize
              VolumeType: gp3
              Encrypted: true
              DeleteOnTermination: "true"

  EC2InstanceA:
    Type: AWS::EC2::Instance
    Properties:
      LaunchTemplate:
        LaunchTemplateId: !Ref LaunchTemplate
        Version: !GetAtt LaunchTemplate.LatestVersionNumber
      SubnetId: '{{resolve:ssm:/net/subnets/publicsubnet1/id}}'
      Tags:
        - Key: Name
          Value: !Sub '${AppName}-ec2-instance-a'

  EC2InstanceB:
    Type: AWS::EC2::Instance
    Properties:
      LaunchTemplate:
        LaunchTemplateId: !Ref LaunchTemplate
        Version: !GetAtt LaunchTemplate.LatestVersionNumber
      SubnetId: '{{resolve:ssm:/net/subnets/publicsubnet2/id}}'
      Tags:
        - Key: Name
          Value: !Sub '${AppName}-ec2-instance-b'

  # AutoScalingGroup:
  #   Type: AWS::AutoScaling::AutoScalingGroup
  #   UpdatePolicy:
  #     AutoScalingRollingUpdate:
  #       MinInstancesInService: 1
  #       MaxBatchSize: 1
  #       PauseTime: PT5M
  #       WaitOnResourceSignals: false
  #   Properties:
  #     AutoScalingGroupName: !Sub "${AppName}-asg"
  #     VPCZoneIdentifier:
  #       - '{{resolve:ssm:/net/subnets/publicsubnet1/id}}'
  #       - '{{resolve:ssm:/net/subnets/publicsubnet2/id}}'
  #     LaunchTemplate:
  #       LaunchTemplateId: !Ref LaunchTemplate
  #       Version: !GetAtt LaunchTemplate.LatestVersionNumber
  #     MinSize: 2 #!Ref ASGMinSize
  #     MaxSize: 2 #!Ref ASGMaxSize
  #     DesiredCapacity: 2 #!Ref ASGDesiredCapacity
  #     TargetGroupARNs:
  #       - !Ref TargetGroup
  #     Tags:
  #       - Key: Name
  #         Value: !Sub "${AppName}-ec2-instance"
  #         PropagateAtLaunch: true

  # ASGCPUPolicy:
  #   Type: AWS::AutoScaling::ScalingPolicy
  #   Properties:
  #     AutoScalingGroupName: !Ref AutoScalingGroup
  #     PolicyType: TargetTrackingScaling
  #     TargetTrackingConfiguration:
  #       PredefinedMetricSpecification:
  #         PredefinedMetricType: ASGAverageCPUUtilization
  #       TargetValue: !Ref CPUPolicyTargetValue

  # RequestCountScalingPolicy:
  #   Type: AWS::AutoScaling::ScalingPolicy
  #   Properties:
  #     AutoScalingGroupName: !Ref AutoScalingGroup
  #     PolicyType: TargetTrackingScaling
  #     TargetTrackingConfiguration:
  #       PredefinedMetricSpecification:
  #         PredefinedMetricType: ALBRequestCountPerTarget
  #         ResourceLabel: !Join 
  #           - '/' 
  #           - - !GetAtt ALB.LoadBalancerFullName
  #             - !GetAtt TargetGroup.TargetGroupFullName
  #       TargetValue: !Ref RequestCountValue

  # ALB Target Group
  TargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Name: !Sub "${AppName}-targetgroup"
      VpcId: "{{resolve:ssm:/net/vpc/id}}"
      Protocol: HTTP
      Port: 80
      TargetType: instance
      HealthCheckPath: "/"
      HealthCheckProtocol: HTTP
      HealthCheckIntervalSeconds: 10
      HealthCheckTimeoutSeconds: 5
      HealthyThresholdCount: 3
      UnhealthyThresholdCount: 2
      Targets:
        - Id: !Ref EC2InstanceA
          Port: 80
        - Id: !Ref EC2InstanceB
          Port: 80
      TargetGroupAttributes:
        - Key: stickiness.enabled
          Value: "true"
        - Key: stickiness.type
          Value: lb_cookie
        - Key: stickiness.lb_cookie.duration_seconds
          Value: "14400"
        - Key: deregistration_delay.timeout_seconds
          Value: '60'
      Tags:
        - Key: Name
          Value: !Sub "${AppName}-targetgroup"

  ALB:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Name: !Sub "${AppName}-loadbalancer"
      Scheme: internet-facing
      Type: application
      SecurityGroups:
        - '{{resolve:ssm:/ec2/securitygroups/lb-sg/id}}'
      Subnets:
        - '{{resolve:ssm:/net/subnets/publicsubnet1/id}}'
        - '{{resolve:ssm:/net/subnets/publicsubnet2/id}}'
      # LoadBalancerAttributes:
      #   - Key: idle_timeout.timeout_seconds
      #     Value: !Ref ALBIdleTimeout
      Tags:
        - Key: Name
          Value: !Sub "${AppName}-alb"

  ACMCertificate:
      Type: AWS::CertificateManager::Certificate
      Properties:
        DomainName: '{{resolve:ssm:/params/acm_domain_name}}'
        SubjectAlternativeNames:
          - '{{resolve:ssm:/params/acm_san}}'
        ValidationMethod: "DNS"

  HTTPListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      LoadBalancerArn: !Ref ALB
      Protocol: HTTP
      Port: 80
      DefaultActions:
        - Type: redirect
          RedirectConfig:
            Protocol: HTTPS
            Port: "443"
            StatusCode: HTTP_301

  WebACL:
    Type: AWS::WAFv2::WebACL
    Properties:
      DefaultAction:
        Allow: {}
      Name: web-acl
      Scope: REGIONAL
      VisibilityConfig:
        SampledRequestsEnabled: true
        CloudWatchMetricsEnabled: true
        MetricName: web-acl
      Rules:
        - Name: AWSCommonRuleSet
          Priority: 1
          OverrideAction:
            Count: {}
          Statement:
            ManagedRuleGroupStatement:
              VendorName: AWS
              Name: AWSManagedRulesCommonRuleSet
              ExcludedRules:
                - Name: SizeRestrictions_BODY
                - Name: SizeRestrictions_QUERYSTRING
          VisibilityConfig:
            SampledRequestsEnabled: true
            CloudWatchMetricsEnabled: true
            MetricName: AWSCommonRuleSet
 
  WebACLAssociation:
    Type: AWS::WAFv2::WebACLAssociation
    Properties:
      ResourceArn: !Ref ALB
      WebACLArn: !GetAtt WebACL.Arn