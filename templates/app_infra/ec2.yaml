AWSTemplateFormatVersion: '2010-09-09'

Parameters:
  AppName:
    Type: String

  KeyPairName:
    Type: String
    Description: Enter a name for the key pair

  BastionAmiId:
    Type: AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>

Resources:

  KeyPairHelperRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal: { Service: lambda.amazonaws.com }
            Action: sts:AssumeRole
      Path: /
      Policies:
        - PolicyName: create-ec2-kp
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - ec2:CreateKeyPair
                  - ec2:DeleteKeyPair
                  - ec2:DescribeKeyPairs
                Resource: "*"
              - Effect: Allow
                Action:
                  - secretsmanager:CreateSecret
                  - secretsmanager:PutSecretValue
                  - secretsmanager:DescribeSecret
                  - secretsmanager:DeleteSecret
                  - secretsmanager:TagResource
                Resource: "*"
              - Effect: Allow
                Action:
                  - kms:Encrypt
                  - kms:GenerateDataKey
                Resource: "*"
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: "*"

  KeyPairHelper:
    Type: AWS::Lambda::Function
    Properties:
      Description: Create/update/delete EC2 key pair and mirror private key in Secrets Manager
      Role: !GetAtt KeyPairHelperRole.Arn
      Runtime: python3.13
      Handler: index.handler
      Timeout: 180

      Code:
        ZipFile: |
          import boto3, json, os, urllib.request
          from botocore.exceptions import ClientError

          ec2 = boto3.client('ec2')
          sm  = boto3.client('secretsmanager')
          ssm = boto3.client('ssm')

          def respond(event, context, status, data=None, physical_id=None, reason=None, no_echo=False):
            if not data: data = {}
            response_body = json.dumps({
              "Status": status,
              "Reason": reason or f"See CloudWatch Logs: {context.log_stream_name}",
              "PhysicalResourceId": physical_id or context.log_stream_name,
              "StackId": event["StackId"],
              "RequestId": event["RequestId"],
              "LogicalResourceId": event["LogicalResourceId"],
              "NoEcho": no_echo,
              "Data": data
            }).encode("utf-8")
            req = urllib.request.Request(event["ResponseURL"], data=response_body, method="PUT")
            req.add_header("Content-Type", "")
            urllib.request.urlopen(req)

          def create_or_rotate_secret(secret_name, secret_string):
            # Create if missing, else put a new version
            try:
              sm.create_secret(Name=secret_name, SecretString=secret_string)
            except ClientError as e:
              if e.response["Error"]["Code"] == "ResourceExistsException":
                sm.put_secret_value(SecretId=secret_name, SecretString=secret_string)
              else:
                raise

          def delete_secret_if_exists(secret_name):
            try:
              sm.describe_secret(SecretId=secret_name)
            except ClientError as e:
              if e.response["Error"]["Code"] in ("ResourceNotFoundException", "InvalidRequestException"):
                return
              raise
            # RecoveryWindowInDays: set to 0 + ForceDeleteWithoutRecovery for immediate delete
            sm.delete_secret(SecretId=secret_name, ForceDeleteWithoutRecovery=True)

          def handler(event, context):
            props = event["ResourceProperties"]
            key_name   = props["KeyPairName"]
            secret_name = props.get("SecretName", f"/ec2/keypairs/{key_name}")

            try:
              if event["RequestType"] in ("Create", "Update"):
                # If Update and key already exists, delete & recreate to ensure material matches secret
                exists = False
                try:
                  ec2.describe_key_pairs(KeyNames=[key_name])
                  exists = True
                except ClientError as e:
                  if e.response["Error"]["Code"] != "InvalidKeyPair.NotFound":
                    raise

                if exists and event["RequestType"] == "Update":
                  ec2.delete_key_pair(KeyName=key_name)

                # Create key pair (returns private material once)
                kp = ec2.create_key_pair(KeyName=key_name)  # default RSA
                pem = kp["KeyMaterial"]

                create_or_rotate_secret(secret_name, pem)

                respond(event, context, "SUCCESS",
                        data={"SecretName": secret_name, "KeyPairName": key_name},
                        physical_id=key_name)

              elif event["RequestType"] == "Delete":
                # Delete both secret and key pair (ignore if gone)
                try:
                  ec2.delete_key_pair(KeyName=key_name)
                except ClientError as e:
                  if e.response["Error"]["Code"] != "InvalidKeyPair.NotFound":
                    raise
                delete_secret_if_exists(secret_name)
                respond(event, context, "SUCCESS", data={}, physical_id=key_name)

              else:
                respond(event, context, "FAILED", reason=f"Unknown RequestType {event['RequestType']}")
            except Exception as e:
              respond(event, context, "FAILED", reason=str(e), physical_id=key_name)

  CreateKeyPair:
    Type: Custom::Ec2KeyToSecret
    Properties:
      ServiceToken: !GetAtt KeyPairHelper.Arn
      KeyPairName:  !Ref KeyPairName

  KeyPairNameParam:
    Type: AWS::SSM::Parameter
    Properties:
      Name: !Sub "/ec2/keypairs/${KeyPairName}/name"
      Type: String
      Value: !Ref KeyPairName

  EC2IAMRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal: { Service: ec2.amazonaws.com }
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
      Tags:
        - Key: env
          Value: '{{resolve:ssm:/params/env_name}}'

  EC2InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      InstanceProfileName: !Sub '{{resolve:ssm:/params/env_name}}-${AppName}'
      Roles: 
        - !Ref EC2IAMRole

  BastionInstance:
    Type: AWS::EC2::Instance
    Properties:
      IamInstanceProfile: !Ref EC2InstanceProfile
      InstanceType: '{{resolve:ssm:/params/bastion_instance_type}}'
      ImageId: !Ref BastionAmiId
      SubnetId: '{{resolve:ssm:/net/subnets/privatesubnet1/id}}' 
      BlockDeviceMappings:
        - DeviceName: /dev/xvda
          Ebs:
            VolumeSize: 20
            VolumeType: gp3
            Encrypted: true
      KeyName: !Ref KeyPairName
      SecurityGroupIds: 
        - '{{resolve:ssm:/ec2/securitygroups/bastion-sg/id}}'
